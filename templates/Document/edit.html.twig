{# templates/document/edit.html.twig #}
{% extends 'base.html.twig' %}
{% block title %}{{ document.title }}{% endblock %}

{% block body %}
    <div class="wrap">
        <div class="card">
            <h1 class="title">Bewerken Set: {{ document.title }}</h1>
            <p class="subtitle">Publiceer Symphonic eMotions muziek sets.</p>

            {% form_theme form 'forms/_theme.html.twig' %}
            {{ form_start(form, { attr: { enctype: 'multipart/form-data' } }) }}

            {# --- Set gegevens (Titel / Grid / BPM) --- #}
            <div class="section">
                <div class="grid grid-2">
                    <div class="grid">
                        {{ form_row(form.title) }}
                    </div>
                    <div class="grid">
                        {{ form_row(form.gridSize) }}
                        {{ form_row(form.setBPM) }}
                    </div>
                </div>
            </div>

            {# --- Assets --- #}
            <div class="section">
                <h2 class="section-title">Assets</h2>
                <div class="grid grid-2">
                    <div>
                        {{ form_row(form.midiFiles) }}
                    </div>

                    <div>
                        <label class="label">MIDI bestanden op server</label>
                        {% if assets is defined and assets|length %}
                            <div class="chips" style="margin-top:8px">
                                {% for a in assets %}
                                    <div class="chip">
                                        <div class="chip-main">
                                            <span class="chip-name">{{ a.originalName }}</span>
                                            <span class="chip-meta subtle">
                                              ({% if a.size is not null %}{{ (a.size / 1024)|number_format(1, '.', ' ') }} KB{% else %}–{% endif %})
                                            </span>
                                        </div>

                                        <div class="chip-actions">
                                            <a href="{{ path('doc_asset_download', { id: document.id, assetId: a.id }) }}" class="btn-mini">Download</a>
                                            <button
                                                    type="button"
                                                    class="btn-mini danger"
                                                    onclick="deleteAsset('{{ path('doc_asset_delete', { id: document.id, assetId: a.id }) }}', '{{ csrf_token('delete-asset-' ~ a.id) }}', '{{ a.originalName }}')"
                                            >
                                                Verwijder
                                            </button>
                                        </div>
                                    </div>
                                {% endfor %}
                            </div>
                        {% else %}
                            <p class="subtle" style="margin-top:6px">
                                Nog geen assets. Upload één of meer .mid-bestanden.
                            </p>
                        {% endif %}
                    </div>
                </div>
            </div>

            {# --- LevelDurations custom UI (tegels) --- #}
            <div class="section">
                <h2 class="section-title">LevelDurations</h2>

                <div class="ld-row">
                    {# 1. Tegels #}
                    <div id="ld-tiles" class="ld-tiles" data-target="#ld-hidden-inputs"></div>

                    {# 2. Knoppen rechts naast de tegels #}
                    <div class="ld-actions">
                        <button type="button" class="btn-mini" id="ld-add">+ Toevoegen</button>
                        <button
                                type="button"
                                class="btn-mini secondary"
                                id="ld-remove"
                        >
                            – Verwijder laatste
                        </button>
                    </div>
                </div>

                {# 3. Verborgen inputs die Symfony leest #}
                <div id="ld-hidden-inputs"
                     class="ld-hidden"
                     data-prototype="{{ form_widget(form.levelDurations.vars.prototype)|e('html_attr') }}"
                     data-index="{{ form.levelDurations|length }}">
                    {% for field in form.levelDurations %}
                        <div class="ld-item">
                            {{ form_widget(field) }}
                        </div>
                    {% endfor %}
                </div>

                {% do form.levelDurations.setRendered %}
            </div>

            {# --- Tracks (DocumentTrack) --- #}
            <div class="section">
                <div class="form-actions" style="margin-top:10px">
                    <button type="button" class="btn" id="add-track">+ Track toevoegen</button>
                </div>

                {# 1) Prototype track-kaart #}
                {% set track_proto %}
                    {% include 'Document/_track_card.html.twig' with {
                        trackForm:   form.tracks.vars.prototype,
                        index:       '__name__',
                        num:         '__num__',
                        isPrototype: true,
                        midiInfo:    {}
                    } only %}
                {% endset %}

                {# 2) Container met bestaande tracks #}
                <div id="tracks"
                     class="tracks"
                     data-index="{{ form.tracks|length }}"
                     data-prototype="{{ track_proto|e('html_attr') }}">

                    {% for trackForm in form.tracks %}
                        {% include 'Document/_track_card.html.twig' with {
                            trackForm:   trackForm,
                            index:       loop.index0,
                            num:         loop.index,
                            isPrototype: false,
                            midiInfo:    midiInfo
                        } only %}
                    {% else %}
                        <p class="subtle">Nog geen tracks. Voeg er één toe.</p>
                    {% endfor %}
                </div>
            </div>

            {{ form_row(form.published) }}

            {# --- Acties onderaan --- #}
            <div class="form-actions">
                <button class="btn" type="submit">Opslaan</button>
                <a class="btn secondary" href="{{ path('app_dashboard') }}">Terug</a>
            </div>

            {# Markeer custom gerenderde velden #}
            {% do form.tracks.setRendered %}

            {{ form_end(form) }}
        </div>
    </div>

    {# ============================================================
       SCRIPT 1: LevelDurations + Tracks + AOI
       ============================================================ #}
    <script>
        (function() {
            const SET_HIDDEN = '#ld-hidden-inputs';
            const SET_TILES  = '#ld-tiles';
            const TRACKS_CONTAINER_ID = 'tracks';

            // ---------- Generic collection helpers ----------
            window.addCollectionItem = function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const index = parseInt(container.dataset.index || '0', 10);
                const proto = container.dataset.prototype?.replace(/__name__/g, index);

                if (!proto) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'collection-item';
                wrapper.innerHTML = proto + '<button type="button" class="btn-mini danger" onclick="removeCollectionItem(this)">×</button>';

                container.appendChild(wrapper);
                container.dataset.index = String(index + 1);
            };

            window.removeCollectionItem = function(btn) {
                const item = btn.closest('.collection-item');
                if (item) item.remove();
            };

            // ---------- Asset delete helper ----------
            window.deleteAsset = function (url, token, filename) {
                if (!confirm(`Weet je zeker dat je ${filename} wilt verwijderen?`)) return;

                const form = document.createElement('form');
                form.method = 'POST';
                form.action = url;

                const tokenInput = document.createElement('input');
                tokenInput.type = 'hidden';
                tokenInput.name = '_token';
                tokenInput.value = token;

                form.appendChild(tokenInput);
                document.body.appendChild(form);
                form.submit();
            };

            // ---------- LevelDurations module ----------
            const LD = {
                _stripRequired(hidden) {
                    hidden.querySelectorAll('input').forEach(inp => {
                        inp.removeAttribute('required');
                        inp.setAttribute('novalidate', 'novalidate');
                    });
                },

                // Locked flag
                _createTile(input, idx, locked = false) {
                    // For locked tiles, force value to 1 always
                    const v = locked ? 1 : (String(input.value || '0') === '1' ? 1 : 0);

                    if (String(input.value) !== String(v)) {
                        input.value = String(v);
                    }

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'ld-square' + (v ? ' on' : '') + (locked ? ' locked' : '');
                    btn.dataset.index = String(idx);

                    // aria-pressed is still based on actual stored value
                    btn.setAttribute('aria-pressed', v ? 'true' : 'false');

                    // VISUAL LABEL:
                    // locked tiles show level number (1-based),
                    // unlocked tiles show the stored 0/1
                    btn.textContent = locked ? String(idx + 1) : String(v);

                    if (!locked) {
                        btn.addEventListener('click', () => {
                            const now = btn.classList.contains('on') ? 0 : 1;
                            btn.classList.toggle('on', !!now);
                            btn.setAttribute('aria-pressed', now ? 'true' : 'false');
                            btn.textContent = String(now);
                            input.value = String(now);
                        });
                    } else {
                        btn.setAttribute('aria-disabled', 'true');
                        btn.title = 'Levels op set-niveau staan altijd aan';
                    }

                    return btn;
                },

                // Locked flag threaded through
                _rebuild(hiddenSel, tilesSel, locked = false) {
                    const hidden = document.querySelector(hiddenSel);
                    const tiles  = document.querySelector(tilesSel);
                    if (!hidden || !tiles) return;

                    tiles.innerHTML = '';
                    this._stripRequired(hidden);

                    const inputs = hidden.querySelectorAll('.ld-item input');
                    inputs.forEach((input, idx) => {
                        const btn = this._createTile(input, idx, locked);
                        tiles.appendChild(btn);
                    });
                },

                add(hiddenSel, tilesSel, locked = false) {
                    const hidden = document.querySelector(hiddenSel);
                    if (!hidden) return;

                    const idx = parseInt(hidden.dataset.index || '0', 10);
                    const proto = hidden.dataset.prototype?.replace(/__name__/g, idx);
                    if (!proto) return;

                    const wrap = document.createElement('div');
                    wrap.className = 'ld-item';
                    wrap.innerHTML = proto;

                    const inp = wrap.querySelector('input');
                    if (inp) {
                        // locked => always 1, otherwise 0
                        inp.value = locked ? '1' : '0';
                        inp.removeAttribute('required');
                        inp.setAttribute('novalidate', 'novalidate');
                    }

                    hidden.appendChild(wrap);
                    hidden.dataset.index = String(idx + 1);

                    this._rebuild(hiddenSel, tilesSel, locked);
                },

                removeLast(hiddenSel, tilesSel, locked = false) {
                    const hidden = document.querySelector(hiddenSel);
                    if (!hidden) return;

                    const items = hidden.querySelectorAll('.ld-item');
                    if (!items.length) return;

                    items[items.length - 1].remove();
                    hidden.dataset.index = String(items.length - 1);

                    this._rebuild(hiddenSel, tilesSel, locked);
                },

                seedIfEmpty(hiddenSel, tilesSel, locked = false) {
                    const hidden = document.querySelector(hiddenSel);
                    if (!hidden) return;

                    const items = hidden.querySelectorAll('.ld-item');
                    if (!items.length) {
                        this.add(hiddenSel, tilesSel, locked);
                    } else {
                        this._rebuild(hiddenSel, tilesSel, locked);
                    }
                },

                resizeTo(hiddenSel, tilesSel, targetLen, locked = false) {
                    const hidden = document.querySelector(hiddenSel);
                    if (!hidden) return;

                    let items = hidden.querySelectorAll('.ld-item');

                    if (items.length > targetLen) {
                        for (let i = items.length - 1; i >= targetLen; i--) {
                            items[i].remove();
                        }
                    }

                    while (hidden.querySelectorAll('.ld-item').length < targetLen) {
                        const i = parseInt(hidden.dataset.index || '0', 10);
                        const proto = hidden.dataset.prototype?.replace(/__name__/g, i);
                        if (!proto) break;

                        const wrap = document.createElement('div');
                        wrap.className = 'ld-item';
                        wrap.innerHTML = proto;

                        const inp = wrap.querySelector('input');
                        if (inp) {
                            // locked => always 1
                            inp.value = locked ? '1' : '0';
                            inp.removeAttribute('required');
                            inp.setAttribute('novalidate', 'novalidate');
                        }

                        hidden.appendChild(wrap);
                        hidden.dataset.index = String(i + 1);
                    }

                    const finalCount = hidden.querySelectorAll('.ld-item').length;
                    hidden.dataset.index = String(finalCount);

                    if (tilesSel) {
                        this._rebuild(hiddenSel, tilesSel, locked);
                    }
                }
            };

            window.LD = LD;

            // ===============================
            // AreaOfInterest (raw JSON input)
            // ===============================
            function getDocGrid() {
                const gridSelect = document.querySelector('select[name$="[gridSize]"]');
                if (gridSelect) {
                    const m = String(gridSelect.value || '').match(/^(\d+)x(\d+)$/);
                    if (m) {
                        return { cols: parseInt(m[1], 10), rows: parseInt(m[2], 10) };
                    }
                }
                return { cols: 1, rows: 1 };
            }

            function parseRawAoi(inputEl) {
                if (!inputEl || !inputEl.value) return [];
                const raw = inputEl.value.trim();
                if (!raw) return [];

                if (raw.startsWith('[')) {
                    try {
                        const arr = JSON.parse(raw);
                        if (Array.isArray(arr)) return arr.map(v => (parseInt(v,10) === 1 ? 1 : 0));
                    } catch(e) {}
                }
                return raw.split(',').map(v => (parseInt(v,10) === 1 ? 1 : 0));
            }

            function storeRawAoi(inputEl, arr) {
                if (!inputEl) return;
                inputEl.value = '[' + arr.join(',') + ']';
            }

            function buildAoiTiles(card, trackIdx) {
                const { cols, rows } = getDocGrid();
                const targetLen = Math.max(1, cols * rows);

                // zoek alle parts in deze track-card
                const partBlocks = card.querySelectorAll('.instrument-part');

                partBlocks.forEach((partBlock, partIdx) => {
                    const tiles = partBlock.querySelector('#aoi-tiles-' + trackIdx + '-' + partIdx);
                    if (!tiles) return;

                    const inputId = tiles.dataset.inputId;
                    const inputEl = document.getElementById(inputId);
                    if (!inputEl) return;

                    let current = parseRawAoi(inputEl);

                    if (current.length === 0) {
                        current = new Array(targetLen).fill(1); // default alles aan
                    } else if (current.length > targetLen) {
                        current = current.slice(0, targetLen);
                    } else if (current.length < targetLen) {
                        current = current.concat(new Array(targetLen - current.length).fill(0));
                    }

                    storeRawAoi(inputEl, current);

                    tiles.innerHTML = '';
                    tiles.style.gridTemplateColumns = `repeat(${cols}, 36px)`;

                    current.forEach((v, i) => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'ld-square' + (v ? ' on' : '');
                        btn.textContent = v ? '1' : '0';
                        btn.setAttribute('aria-pressed', v ? 'true' : 'false');

                        btn.addEventListener('click', () => {
                            const now = btn.classList.contains('on') ? 0 : 1;
                            btn.classList.toggle('on', !!now);
                            btn.textContent = String(now);
                            btn.setAttribute('aria-pressed', now ? 'true' : 'false');

                            current[i] = now;
                            storeRawAoi(inputEl, current);
                        });

                        tiles.appendChild(btn);
                    });
                });
            }

            function syncAllAoIToDocGrid() {
                document.querySelectorAll('#tracks .track-card').forEach((card, i) => {
                    buildAoiTiles(card, i);
                });
            }


            // ---------- Tracks module ----------
            const tracksContainer = document.getElementById(TRACKS_CONTAINER_ID);

            function getSetLevelCount() {
                const hidden = document.querySelector(SET_HIDDEN);
                return hidden ? hidden.querySelectorAll('.ld-item').length : 0;
            }

            function syncAllTracksToSetCount() {
                const targetLen = getSetLevelCount();
                if (!tracksContainer) return;

                document.querySelectorAll('#tracks .track-card').forEach((card, i) => {
                    const hidden = card.querySelector('#trk-hidden-' + i);
                    const tiles  = card.querySelector('#trk-tiles-' + i);
                    if (hidden && tiles) {
                        LD.resizeTo('#' + hidden.id, '#' + tiles.id, targetLen);
                    }
                });
            }

            function ensureAtLeastOnePart(card, trackIdx) {
                const partsContainer = card.querySelector('#parts-' + trackIdx);
                if (!partsContainer) return;

                // als er al parts zijn, klaar
                if (card.querySelectorAll('.instrument-part').length > 0) return;

                const pIndex = parseInt(partsContainer.dataset.index || '0', 10);
                const proto  = partsContainer.dataset.prototype?.replace(/__name__/g, pIndex);
                if (!proto) return;

                // proto is enkel het form field (TextType). We bouwen er dezelfde wrapper omheen als Twig.
                const tmp = document.createElement('div');
                tmp.innerHTML = proto.trim();
                const partField = tmp.firstElementChild;
                if (!partField) return;

                const wrap = document.createElement('div');
                wrap.className = 'instrument-part';
                wrap.dataset.partIndex = String(pIndex);

                wrap.innerHTML = `
        <div class="label-with-tiles">
            <label class="label">Area of interest (part ${pIndex + 1})</label>
            <div id="aoi-tiles-${trackIdx}-${pIndex}"
                 class="aoi-tiles"
                 data-input-id=""></div>
        </div>
        <div class="ld-hidden"></div>
    `;

                wrap.querySelector('.ld-hidden').appendChild(partField);

                const tilesDiv = wrap.querySelector('.aoi-tiles');
                tilesDiv.dataset.inputId = partField.id;

                partsContainer.appendChild(wrap);
                partsContainer.dataset.index = String(pIndex + 1);
            }

            function wireNewTrackCard(card, idx) {
                // levels...
                const hidden = card.querySelector('#trk-hidden-' + idx);
                const tiles  = card.querySelector('#trk-tiles-' + idx);

                if (hidden && tiles) {
                    LD.seedIfEmpty('#' + hidden.id, '#' + tiles.id);
                    LD.resizeTo('#' + hidden.id, '#' + tiles.id, getSetLevelCount());
                }

                // parts seeden voor nieuwe tracks
                ensureAtLeastOnePart(card, idx);

                // AOI tiles bouwen
                buildAoiTiles(card, idx);
            }

            function addTrackFromPrototype() {
                if (!tracksContainer) return;

                const index = parseInt(tracksContainer.dataset.index || '0', 10);
                let html = String(tracksContainer.dataset.prototype || '')
                    .replace(/__name__/g, index)
                    .replace(/__num__/g, index + 1);

                if (!html) return;

                const wrapper = document.createElement('div');
                wrapper.innerHTML = html;
                const card = wrapper.firstElementChild;

                tracksContainer.appendChild(card);
                tracksContainer.dataset.index = String(index + 1);

                wireNewTrackCard(card, index);
            }

            window.removeTrack = function(btn) {
                btn.closest('.track-card')?.remove();
            };

            // ---------- INIT ----------
            if (tracksContainer) {
                document
                    .querySelectorAll('#tracks .track-card')
                    .forEach((card, i) => wireNewTrackCard(card, i));
            }

            LD.seedIfEmpty(SET_HIDDEN, SET_TILES, true);
            syncAllTracksToSetCount();
            syncAllAoIToDocGrid();

            const ldAddBtn    = document.getElementById('ld-add');
            const ldRemoveBtn = document.getElementById('ld-remove');
            // luister naar gridSize changes
            const gridSelect = document.querySelector('select[name$="[gridSize]"]');

            if (gridSelect) {
                gridSelect.addEventListener('change', () => {
                    syncAllAoIToDocGrid();
                });
            }

            if (ldAddBtn) {
                ldAddBtn.addEventListener('click', () => {
                    LD.add(SET_HIDDEN, SET_TILES, true);
                    syncAllTracksToSetCount();
                });
            }

            if (ldRemoveBtn) {
                ldRemoveBtn.addEventListener('click', () => {
                    LD.removeLast(SET_HIDDEN, SET_TILES, true);
                    syncAllTracksToSetCount();
                });
            }

            document.getElementById('add-track')
                ?.addEventListener('click', addTrackFromPrototype);

            const form = document.querySelector('form');
            if (form) {
                form.addEventListener('submit', () => {
                    document
                        .querySelectorAll('.ld-hidden')
                        .forEach(h => LD._stripRequired(h));
                });
            }

        })();
    </script>

    {# ============================================================
       SCRIPT 2: Loop editor (loopLength + override)
       ============================================================ #}
    <script>
        (function () {
            function initLoopEditors() {
                const editors = document.querySelectorAll('.js-loop-editor');

                editors.forEach(function (editor) {
                    if (editor.dataset.loopInitialized === '1') {
                        return;
                    }
                    editor.dataset.loopInitialized = '1';

                    const totalBars = parseInt(editor.dataset.totalBars || '0', 10);
                    const timeSig   = editor.dataset.timesig || editor.dataset.timeSig || '4/4';
                    const [numStr, denStr] = timeSig.split('/');
                    const groupSize = parseInt(numStr || '4', 10) || 4;

                    const hiddenInputId = editor.dataset.inputId;
                    const hiddenInput   = document.getElementById(hiddenInputId);
                    const chipsContainer = editor.querySelector('.js-loop-chips');
                    const baseInput      = editor.querySelector('.js-loop-base-input');

                    const resetBtn   = editor.querySelector('.js-loop-reset');
                    const addBtn     = editor.querySelector('.js-loop-add');
                    const removeBtn  = editor.querySelector('.js-loop-remove');
                    const baseDecBtn = editor.querySelector('.js-loop-base-dec');
                    const baseIncBtn = editor.querySelector('.js-loop-base-inc');

                    function parseValueFromHidden() {
                        if (!hiddenInput || !hiddenInput.value) {
                            return [];
                        }

                        let raw = hiddenInput.value.trim();
                        let arr = [];

                        if (raw.startsWith('[')) {
                            try {
                                const parsed = JSON.parse(raw);
                                if (Array.isArray(parsed)) {
                                    arr = parsed;
                                }
                            } catch (e) {
                                // negeren
                            }
                        } else {
                            arr = raw.split(',').map(function (v) { return parseInt(v, 10); });
                        }

                        return arr
                            .map(function (v) { return parseInt(v, 10); })
                            .filter(function (v) { return !Number.isNaN(v) && v > 0; });
                    }

                    function storeValue(values) {
                        if (!hiddenInput) {
                            return;
                        }
                        hiddenInput.value = '[' + values.join(',') + ']';
                    }

                    function renderChips(values) {
                        chipsContainer.innerHTML = '';

                        if (!values.length) {
                            const span = document.createElement('span');
                            span.className = 'loop-empty';
                            span.textContent = 'Geen looplengte berekend';
                            chipsContainer.appendChild(span);
                            return;
                        }

                        values.forEach(function (len, idx) {
                            const chip = document.createElement('span');
                            chip.className = 'loop-chip';
                            chip.textContent = 'Loop ' + (idx + 1) + ': ' + len + ' maten';
                            chipsContainer.appendChild(chip);
                        });
                    }

                    function getOverrideBase() {
                        if (!baseInput) {
                            return null;
                        }

                        const raw = (baseInput.value || '').trim();
                        if (!raw) {
                            return null;
                        }

                        const val = parseInt(raw, 10);
                        if (Number.isNaN(val) || val < 1) {
                            return null;
                        }

                        return val;
                    }

                    function computeEffectiveBase() {
                        let computedBase = null;

                        if (totalBars > 0 && groupSize > 0) {
                            const q = Math.floor(totalBars / groupSize) * groupSize;
                            if (q >= 1) {
                                computedBase = q;
                            }
                        }

                        const override = getOverrideBase();

                        let candidate;
                        if (override !== null) {
                            candidate = override;
                        } else if (computedBase !== null) {
                            candidate = computedBase;
                        } else {
                            candidate = 8;
                        }

                        if (groupSize > 0) {
                            const q = Math.floor(candidate / groupSize) * groupSize;
                            return Math.max(1, q);
                        }

                        return Math.max(1, candidate);
                    }

                    function recalcForSegmentCount(count) {
                        const base = computeEffectiveBase();
                        if (base <= 0 || count <= 0 || groupSize <= 0) {
                            return [];
                        }

                        const rawSegment = base / count;
                        const quantized  = Math.floor(rawSegment / groupSize) * groupSize;

                        if (quantized <= 0) {
                            return [];
                        }

                        return new Array(count).fill(quantized);
                    }

                    let current = parseValueFromHidden();
                    if (!current.length) {
                        const base = computeEffectiveBase();
                        if (base > 0) {
                            current = [base];
                            storeValue(current);

                            // Toon de berekende basis ook in het basismaten-veld
                            if (baseInput && !(baseInput.value || '').trim()) {
                                baseInput.value = String(base);
                            }
                        }
                    }
                    renderChips(current);

                    function updateLoopsFromBaseChange() {
                        const loopsCount = current.length || 1;

                        if (loopsCount <= 0) {
                            const base = computeEffectiveBase();
                            if (base <= 0) {
                                return;
                            }
                            current = [base];
                        } else if (loopsCount === 1) {
                            const base = computeEffectiveBase();
                            if (base <= 0) {
                                return;
                            }
                            current = [base];
                        } else {
                            const next = recalcForSegmentCount(loopsCount);
                            if (!next.length) {
                                return;
                            }
                            current = next;
                        }

                        storeValue(current);
                        renderChips(current);
                    }

                    if (resetBtn) {
                        resetBtn.addEventListener('click', function () {
                            // Override loslaten
                            if (baseInput) {
                                baseInput.value = '';
                            }

                            const base = computeEffectiveBase();
                            if (base <= 0) {
                                return;
                            }

                            // Basismaten veld ook invullen met de berekende basis
                            if (baseInput) {
                                baseInput.value = String(base);
                            }

                            current = [base];
                            storeValue(current);
                            renderChips(current);
                        });
                    }

                    if (addBtn) {
                        addBtn.addEventListener('click', function () {
                            const nextCount = (current.length || 1) + 1;
                            const next = recalcForSegmentCount(nextCount);
                            if (!next.length) {
                                return;
                            }
                            current = next;
                            storeValue(current);
                            renderChips(current);
                        });
                    }

                    if (removeBtn) {
                        removeBtn.addEventListener('click', function () {
                            if (current.length <= 1) {
                                return;
                            }
                            const nextCount = current.length - 1;
                            const next = recalcForSegmentCount(nextCount);
                            if (!next.length) {
                                return;
                            }
                            current = next;
                            storeValue(current);
                            renderChips(current);
                        });
                    }

                    if (baseDecBtn && baseInput) {
                        baseDecBtn.addEventListener('click', function () {
                            const raw = (baseInput.value || '').trim();

                            let val;
                            if (!raw) {
                                val = computeEffectiveBase();
                            } else {
                                val = parseInt(raw, 10);
                                if (Number.isNaN(val) || val < 1) {
                                    val = computeEffectiveBase();
                                }
                            }

                            const step = groupSize > 0 ? groupSize : 1;
                            val = val - step;
                            if (val < 1) {
                                val = 1;
                            }

                            baseInput.value = String(val);
                            updateLoopsFromBaseChange();
                        });
                    }

                    if (baseIncBtn && baseInput) {
                        baseIncBtn.addEventListener('click', function () {
                            const raw = (baseInput.value || '').trim();

                            let val;
                            if (!raw) {
                                val = computeEffectiveBase();
                            } else {
                                val = parseInt(raw, 10);
                                if (Number.isNaN(val) || val < 1) {
                                    val = computeEffectiveBase();
                                }
                            }

                            const step = groupSize > 0 ? groupSize : 1;
                            val = val + step;

                            baseInput.value = String(val);
                            updateLoopsFromBaseChange();
                        });
                    }

                    if (baseInput) {
                        baseInput.addEventListener('change', function () {
                            const raw = (baseInput.value || '').trim();
                            if (!raw) {
                                baseInput.value = '';
                                updateLoopsFromBaseChange();
                                return;
                            }

                            const val = parseInt(raw, 10);
                            if (Number.isNaN(val) || val < 1) {
                                baseInput.value = '';
                            } else {
                                baseInput.value = String(val);
                            }

                            updateLoopsFromBaseChange();
                        });
                    }
                });
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initLoopEditors);
            } else {
                initLoopEditors();
            }

            document.addEventListener('turbo:load', initLoopEditors);
            document.addEventListener('turbo:render', initLoopEditors);
        })();
    </script>

{% endblock %}
